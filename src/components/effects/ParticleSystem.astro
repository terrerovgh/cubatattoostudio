---
export interface Props {
  variant?: 'floating' | 'magnetic' | 'orbit' | 'flow' | 'constellation';
  density?: 'low' | 'medium' | 'high';
  color?: 'white' | 'gray' | 'accent';
  size?: 'sm' | 'md' | 'lg';
  speed?: 'slow' | 'medium' | 'fast';
  interactive?: boolean;
  class?: string;
}

const {
  variant = 'floating',
  density = 'medium',
  color = 'white',
  size = 'md',
  speed = 'medium',
  interactive = true,
  class: className = ''
} = Astro.props;

const baseClasses = 'particle-system absolute inset-0 pointer-events-none overflow-hidden';
const classes = `${baseClasses} ${className}`;

// Configuraciones de densidad
const densityConfig = {
  low: 15,
  medium: 30,
  high: 50
};

// Configuraciones de tamaño
const sizeConfig = {
  sm: { min: 1, max: 3 },
  md: { min: 2, max: 6 },
  lg: { min: 4, max: 10 }
};

// Configuraciones de velocidad
const speedConfig = {
  slow: { min: 0.5, max: 1.5 },
  medium: { min: 1, max: 3 },
  fast: { min: 2, max: 5 }
};

const particleCount = densityConfig[density];
const sizeRange = sizeConfig[size];
const speedRange = speedConfig[speed];
---

<div class={classes} data-particle-variant={variant} data-particle-interactive={interactive}>
  <canvas 
    class="particle-canvas w-full h-full" 
    data-particle-count={particleCount}
    data-particle-color={color}
    data-size-min={sizeRange.min}
    data-size-max={sizeRange.max}
    data-speed-min={speedRange.min}
    data-speed-max={speedRange.max}
  ></canvas>
</div>

<style>
  .particle-system {
    z-index: 1;
  }
  
  .particle-canvas {
    opacity: 0.6;
    mix-blend-mode: screen;
  }
</style>

<script>
  import { gsap } from 'gsap';

  class ParticleSystem {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.particles = [];
      this.mouse = { x: 0, y: 0 };
      this.isInteractive = canvas.dataset.particleInteractive === 'true';
      this.variant = canvas.dataset.particleVariant || 'floating';
      
      this.config = {
        count: parseInt(canvas.dataset.particleCount) || 30,
        color: canvas.dataset.particleColor || 'white',
        sizeMin: parseFloat(canvas.dataset.sizeMin) || 2,
        sizeMax: parseFloat(canvas.dataset.sizeMax) || 6,
        speedMin: parseFloat(canvas.dataset.speedMin) || 1,
        speedMax: parseFloat(canvas.dataset.speedMax) || 3
      };
      
      this.init();
    }
    
    init() {
      this.resize();
      this.createParticles();
      this.bindEvents();
      this.animate();
    }
    
    resize() {
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width;
      this.canvas.height = rect.height;
    }
    
    createParticles() {
      this.particles = [];
      
      for (let i = 0; i < this.config.count; i++) {
        const particle = {
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          size: this.config.sizeMin + Math.random() * (this.config.sizeMax - this.config.sizeMin),
          speedX: (Math.random() - 0.5) * (this.config.speedMin + Math.random() * this.config.speedMax),
          speedY: (Math.random() - 0.5) * (this.config.speedMin + Math.random() * this.config.speedMax),
          opacity: 0.3 + Math.random() * 0.7,
          angle: Math.random() * Math.PI * 2,
          angleSpeed: (Math.random() - 0.5) * 0.02,
          originalX: 0,
          originalY: 0,
          magneticForce: 0
        };
        
        particle.originalX = particle.x;
        particle.originalY = particle.y;
        
        this.particles.push(particle);
      }
    }
    
    updateParticle(particle) {
      switch (this.variant) {
        case 'floating':
          particle.y += particle.speedY;
          particle.x += Math.sin(particle.angle) * 0.5;
          particle.angle += particle.angleSpeed;
          
          if (particle.y < -particle.size) {
            particle.y = this.canvas.height + particle.size;
            particle.x = Math.random() * this.canvas.width;
          }
          break;
          
        case 'magnetic':
          if (this.isInteractive) {
            const dx = this.mouse.x - particle.x;
            const dy = this.mouse.y - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 150;
            
            if (distance < maxDistance) {
              const force = (maxDistance - distance) / maxDistance;
              particle.magneticForce = force * 0.1;
              particle.x += dx * particle.magneticForce;
              particle.y += dy * particle.magneticForce;
            } else {
              // Volver gradualmente a la posición original
              particle.x += (particle.originalX - particle.x) * 0.02;
              particle.y += (particle.originalY - particle.y) * 0.02;
            }
          }
          break;
          
        case 'orbit':
          particle.angle += particle.angleSpeed;
          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;
          const radius = 100 + particle.size * 10;
          
          particle.x = centerX + Math.cos(particle.angle) * radius;
          particle.y = centerY + Math.sin(particle.angle) * radius;
          break;
          
        case 'flow':
          particle.x += particle.speedX;
          particle.y += particle.speedY;
          
          // Efecto de flujo suave
          particle.speedY += Math.sin(particle.x * 0.01) * 0.1;
          particle.speedX += Math.cos(particle.y * 0.01) * 0.1;
          
          // Wrap around
          if (particle.x > this.canvas.width + particle.size) {
            particle.x = -particle.size;
          }
          if (particle.y > this.canvas.height + particle.size) {
            particle.y = -particle.size;
          }
          break;
          
        case 'constellation':
          particle.x += particle.speedX * 0.3;
          particle.y += particle.speedY * 0.3;
          particle.angle += particle.angleSpeed;
          
          // Boundaries
          if (particle.x < 0 || particle.x > this.canvas.width) particle.speedX *= -1;
          if (particle.y < 0 || particle.y > this.canvas.height) particle.speedY *= -1;
          break;
      }
    }
    
    drawParticle(particle) {
      this.ctx.save();
      
      // Color configuration
      let color;
      switch (this.config.color) {
        case 'white':
          color = `rgba(255, 255, 255, ${particle.opacity})`;
          break;
        case 'gray':
          color = `rgba(160, 160, 160, ${particle.opacity})`;
          break;
        case 'accent':
          color = `rgba(255, 255, 255, ${particle.opacity * 0.8})`;
          break;
        default:
          color = `rgba(255, 255, 255, ${particle.opacity})`;
      }
      
      this.ctx.fillStyle = color;
      this.ctx.shadowColor = color;
      this.ctx.shadowBlur = particle.size * 2;
      
      // Draw particle
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Draw connections for constellation variant
      if (this.variant === 'constellation') {
        this.particles.forEach(otherParticle => {
          if (otherParticle !== particle) {
            const dx = particle.x - otherParticle.x;
            const dy = particle.y - otherParticle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
              const opacity = (100 - distance) / 100 * 0.2;
              this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
              this.ctx.lineWidth = 0.5;
              this.ctx.beginPath();
              this.ctx.moveTo(particle.x, particle.y);
              this.ctx.lineTo(otherParticle.x, otherParticle.y);
              this.ctx.stroke();
            }
          }
        });
      }
      
      this.ctx.restore();
    }
    
    animate() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      this.particles.forEach(particle => {
        this.updateParticle(particle);
        this.drawParticle(particle);
      });
      
      requestAnimationFrame(() => this.animate());
    }
    
    bindEvents() {
      if (this.isInteractive) {
        this.canvas.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          this.mouse.x = e.clientX - rect.left;
          this.mouse.y = e.clientY - rect.top;
        });
        
        this.canvas.addEventListener('mouseleave', () => {
          this.mouse.x = -1000;
          this.mouse.y = -1000;
        });
      }
      
      window.addEventListener('resize', () => {
        this.resize();
        this.createParticles();
      });
    }
  }
  
  // Initialize particle systems
  function initParticleSystems() {
    const canvases = document.querySelectorAll('.particle-canvas');
    canvases.forEach(canvas => {
      new ParticleSystem(canvas);
    });
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initParticleSystems);
  } else {
    initParticleSystems();
  }
  
  // Reinitialize on page navigation
  document.addEventListener('astro:page-load', initParticleSystems);
</script>